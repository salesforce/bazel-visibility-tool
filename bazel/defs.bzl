"""Macros and data structures for dealing with visibility management."""

VisibilityGroupInfo = provider(
    doc = """Provides information about visibility groups definitions.""",
    fields = {
        "name": "string: Canonical group name",
        "label": "Label: Label of the group rule (all groups are expected to be defined in the same visibility package)",
        "package_group": "Label: A `package_group` which represents this visibility group. This can either be a manually or otherwise programmatically maintained `package_group` or a group generated by the Visibility Tool (based on querying the graph). In either case it represents this group and will be used in the visibility matrix.",
        "visible_to_groups": "list(string): List of group name to make the group visible to (default is `[]`)",
        "visibility_allow_list": "label: An (optional) allow list `package_group` listing additional packages which the group will be made visible to as well",
    },
)

VisibilityPackageInfo = provider(
    doc = """Provides information about a package visibility.""",
    fields = {
        "package": "label: the actual package defining the info (may not be available at loading time)",
        "package_name": "string: the package name to define the info for",
        "group": "label: visibility group the package belongs to",
    },
)

VisibilityMavenDepsInfo = provider(
    doc = """Provides information about bazel_maven_deps visibility.""",
    fields = {
        "group": "label: visibility group the dependencies belong to",
        "include_patterns": "list(string): List of patterns for matching dependencies to include into the group (must start with `@`)",
        "exclude_patterns": "list(string): List of patterns for matching dependencies to exclude from the group (must start with `@`)",
    },
)

def _visibility_group_impl(ctx):
    group_label = "@%s//%s:%s" % (
        ctx.label.workspace_name,
        ctx.label.package,
        ctx.label.name,
    )
    provider = VisibilityGroupInfo(
        name = ctx.attr.name,
        label = group_label,
        package_group = ctx.attr.package_group,
        visible_to_groups = ctx.attr.visible_to_groups,
        visibility_allow_list = ctx.attr.visibility_allow_list,
    )
    return [provider]

visibility_group_definition = rule(
    implementation = _visibility_group_impl,
    doc = "A rule for defining visibility groups.",
    attrs = {
        "package_group": attr.label(
            doc = "A `package_group` which represents this visibility group. This can either be a manually or otherwise programmatically maintained `package_group` or a group generated by the Visibility Tool (based on querying the graph). In either case it represents this group and will be used in the visibility matrix.",
            providers = [PackageSpecificationInfo],
        ),
        "visible_to_groups": attr.string_list(
            doc = "A list of group names the group is visible to. These are not full labels but only names. Group names are expected to be unique regardless of the package.",
        ),
        "visibility_allow_list": attr.label(
            doc = "An (optional) allow list `package_group` listing additional packages which the group will be made visible to as well",
            providers = [PackageSpecificationInfo],
        ),
    },
)

def visibility_group(name, **kwargs):
    """Generates the visibility_group_definition target for defining a visibility group.

    Visibility groups define metadata about visibility groups.

    Visibility groups should be as targeted as possible. Each Bazel package (and target) must be listed in at most one visibility group.
    This allows to reduce cognitive load and avoid dealing with complicated AND, OR, XOR or XAND situations.

    You can use the Visibility Tool to generate/update `package_group` information based on `package_visibility_info` definitions.
    Or manually mainten a `package_group` or programatically generate them via macros at loading time.

    Args:
      name: `string`
        The canonical name of the visibility group.
      **kwargs: `additional visibility_group_definition rule attributes`
        Additional keyword arguments to pass to visibility_group_definition rule definition.
    """
    visibility_group_definition(
        name = name,
        **kwargs
    )

def _visibility_package_info_impl(ctx):
    package_label = "@%s//%s" % (
        ctx.label.workspace_name,
        ctx.label.package
    )
    provider = VisibilityPackageInfo(
        package = package_label,
        group = ctx.attr.group,
    )
    return [provider]

visibility_package_info_definition = rule(
    implementation = _visibility_package_info_impl,
    doc = "A rule for defining package visibility information. The rule will auto-populate the `package` field based on the context.",
    attrs = {
        "group": attr.label(
            doc = "The visibility group the package belongs to.",
            providers = [VisibilityGroupInfo],
            mandatory = True,
        ),
        "package_name": attr.string(
            doc = "The package name to define the visibility group info for.",
            mandatory = True,
        ),
    },
)

def package_visibility_info(group, package_name = None, **kwargs):
    """Generates the data map for defining a package's visibility info.

    Visibility package info define metadata within a package to associate a package with a visibility group.

    This macro shall be used only once part package. 
    To enfoce this the name is hard coded to `package_visibility_info`.

    Args:
      group: `label`
        Visibility group the package belongs to
      package_name: 'string'
        Value of `native.package_name()`
      **kwargs: `additional visibility_package_info_definition rule attributes`
        Additional keyword arguments to pass to _visibility_group rule definition.
    """
    kwargs.pop("name", "")

    # no matter what was submitted, we ensure it's native.package_name()
    # (having this as a parameter helps with Bazel query)
    kwargs.pop("package_name", "")
    package_name = native.package_name()

    visibility_package_info_definition(
        name = "package_visibility_info",
        group = group,
        package_name = package_name,
        **kwargs
    )

def _visibility_maven_deps_impl(ctx):
    provider = VisibilityMavenDepsInfo(
        group = ctx.attr.group,
        include_patterns = ctx.attr.include_patterns,
        exclude_patterns = ctx.attr.exclude_patterns,
    )
    return [provider]

visibility_maven_deps_definition = rule(
    implementation = _visibility_maven_deps_impl,
    doc = "A rule for defining bazel_maven_deps visibility information.",
    attrs = {
        "group": attr.label(
            doc = "The visibility group the package belongs to.",
            providers = [VisibilityGroupInfo],
            mandatory = True,
        ),
        "include_patterns": attr.string_list(
            doc = "A list of wildcard glob patterns selecting dependencies to include to the group." +
                  " A pattern is expected to start with the at char `@` to confirm the beginning of an external repository name." +
                  " At this time only `**` or `*` wildcards are supported.",
            mandatory = True,
            allow_empty = False,
        ),
        "exclude_patterns": attr.string_list(
            doc = "A list of wildcard glob patterns selecting dependencies to exclude from the group." +
                  " A pattern is expected to start with the at char `@` to confirm the beginning of an external repository name." +
                  " At this time only `**` or `*` wildcards are supported.",
        ),
    },
)

def maven_deps_visibility_info(group, **kwargs):
    """Generates the data map for defining a bazel_maven_deps visibility info.

    The Visibility Tool integrates with bazel_maven_deps to allow populating dependencies in the
    pinned catalog with visibility information.

    It's recommended to create the infos within the visibility package in a subpackage.
    By default the group name will be used to generate a target name.
    Please provide a `name` property if you intend to provide more then one definition per group.
    Allthough, we strongly recommend not cluttering definitions and only provide one per group.

    Args:
      group: `label`
        Visibility group the package belongs to (will be used for populating a name)
      **kwargs: `additional visibility_maven_deps_definition rule attributes`
        Additional keyword arguments to pass to visibility_maven_deps_definition rule definition.
    """
    if type(group) == "string":
        group = native.package_relative_label(group)
    elif type(group) != "Label":
        fail("Invalid type for argument 'group'. Expected 'Label' but got: %s" % type(group))

    visibility_maven_deps_definition(
        name = kwargs.pop("name", "maven_deps_visibility_" + group.name),
        group = group,
        **kwargs
    )
